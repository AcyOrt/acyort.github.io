<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="keywords" content="acyort, nodejs, blog" />
<meta name="description" content="A Node.js blog tool powered by GitHub." />
<link rel="icon" href="/icon.png" />
<link rel="stylesheet" href="/css/style.css" />

  <title>
Page Visibility 初探 - AcyOrt
</title>
</head>

<body>

<div class="main">

<div class="header">
    <div class="center">
        <a class="logo" href="/">AcyOrt</a>

        <div class="menu">
            <div class="menuicon"></div>

            <div class="menuitem">
            
            <a href="/">home</a>
            
            <a href="/about">about</a>
            
            <a href="/">archives</a>
            
            </div>
        </div>
    </div>
</div>




<div id="post" class="center">

    <p class="time">May 16, 2013</p> 

    <h1 class="title">Page Visibility 初探</h1>

    <div class="content"><p><img src="https://f.cloud.github.com/assets/97227/512680/31ae0242-be2f-11e2-8f1f-166a71cc5fa3.png" alt="screen shot 2013-05-16 at 9 47 19 pm"></p>
<p>前天，<a href="http://www.w3.org/TR/2013/REC-page-visibility-20130514/">Page Visibility</a> 正式成为 W3C 推荐规范。为什么需要有这个规范呢？</p>
<h2 id="来由">来由</h2><p>遥想 IE6 时代，就有用户喜欢一次性打开多个页面，然后逐个查看。随着标签页成为浏览器的标配，以及硬件性能的提升，一个用户电脑上同时打开很多标签页，是司空见惯的事情。这带来一些思考：</p>
<ol>
<li><p>处于当前焦点的页面永远只有一个，但用户的屏幕越来越大，处于可见状态的页面往往不止一个。</p>
</li>
<li><p>当页面处于不可见状态时，UI 绘制、更新轮询等代码执行，往往可以停下来或频率变慢，这可以节省 CPU 等硬件损耗。对移动设备来说特别重要，能延长电池续航时间。</p>
</li>
<li><p>但之前各个浏览器并不提供 API 来直接判断页面的可见性。可以通过 <code>window.focus / blur</code> 以及其他一些奇技淫巧来间接判断，但并不靠谱。</p>
</li>
</ol>
<p>有明确的需求，却无法很好地通过代码来实现，这时就诞生了提议、规范。Page Visibility 就是用来规范页面可见性的接口文档，让各个浏览器对外的接口一致。</p>
<h2 id="规范">规范</h2><p>Page Visibility 规范明确了 document 上的两个属性：</p>
<pre><code class="lang-js"><span class="hljs-built_in">document</span>.hidden
<span class="hljs-built_in">document</span>.visibilityState
</code></pre>
<p><code>hidden</code> 是布尔值，<code>true</code> 表示页面不可见，<code>false</code> 表示可见。</p>
<p>要理解 <code>hidden</code> 属性的真正含义，得仔细推敲下『可见』。</p>
<p><strong>根据规范，『可见』是指，页面中至少有部分内容在屏幕上对用户可见。</strong></p>
<p>按照上面的定义，『不可见』理论上应该包含以下各种情况：</p>
<ol>
<li>页面是后台标签页，不是当前标签页。</li>
<li>页面所在浏览器窗口处于最小化状态。</li>
<li>页面所在浏览器的位置不在当前屏幕。</li>
<li>页面所在浏览器被当前屏幕的其他程序完全遮挡住。</li>
<li>用户屏幕处于锁屏或关闭等状态。</li>
</ol>
<p>理想与现实总是存在距离。截至今天为止，各个浏览器对『不可见』的理解还存在差异：</p>
<ol>
<li>在 Chrome 和 Safari 等 WebKit 浏览器下，仅当页面是后台标签页时，页面状态才不可见。</li>
<li>在 Firefox 下，页面是后台标签页，或所在窗口处于最小化状态时，页面状态都为不可见。</li>
<li>Opera 跟 Chrome 一样。</li>
<li>IE10 没测。</li>
</ol>
<p>可以看出，实际使用时，『可见』的含义是指：</p>
<p><strong>『可见』表示，页面是非最小化浏览器窗口的当前标签页。</strong></p>
<p>Firefox 的实现目前最靠近理想情况，Chrome 等浏览器仅考虑了最简单的情况，还有待完善。</p>
<p>一般来说，<code>document.hidden</code> 属性就够用了。但在要求非常高的页面中，需要使用到 <code>document.visibilityState</code> 属性。</p>
<p><code>visibilityState</code> 是字符串，可取以下值：</p>
<ol>
<li><code>hidden</code> 表示页面不可见。</li>
<li><code>visible</code> 表示页面可见。</li>
<li><code>prerender</code> 表示页面正在预处理阶段，还未显示出来。</li>
<li><code>unloaded</code> 表示页面虽然还显示着，但已经要被 unload 了。</li>
</ol>
<p>前两个值不再解释。后两个值很有意思：</p>
<ol>
<li><p>当前标签页处于初始加载，还未渲染出来时，因为是当前标签页，<code>document.hidden</code> 是 <code>false</code>，但这时页面其实并不可见（还未渲染出来），这时 <code>visibilityState</code> 的值就是 <code>prerender</code>，可用来精准判断初始渲染阶段。</p>
</li>
<li><p>类似的，当发生前进、后退、关闭等操作时，虽然当前页面依旧可见，但实际上可以按照不可见来处理了。这时 <code>document.hidden</code> 是 <code>false</code>，<code>document.visibilityState</code> 则是 <code>unloaded</code>。</p>
</li>
</ol>
<p>注意：<code>prerender</code> 和 <code>unloaded</code> 这两个值，目前稳定版 Chrome 和 Firefox 都尚未支持，暂时慎用。以后 <code>visibilityState</code> 应该还可以有更多值，包括当前窗口被其他窗口完全遮挡住的情形，很可能也会用某个值来表示。</p>
<p>除了以上两个属性值，还可以通过 <code>document</code> 的 <code>visibilitychange</code> 事件来监听 <code>visibilityState</code> 的状态变化，这个就不多说了。</p>
<h2 id="实践">实践</h2><p>目前除了 Opera，其他浏览器都需要添加前缀：</p>
<pre><code class="lang-js">document<span class="hljs-selector-class">.webkitHidden</span>
document<span class="hljs-selector-class">.mozHidden</span>
document<span class="hljs-selector-class">.msHidden</span> <span class="hljs-comment">// IE10</span>
</code></pre>
<p>具体示例代码，可以参考下面两份文档：</p>
<ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API">MDN: Using the Page Visibility API</a></li>
<li><a href="https://developers.google.com/chrome/whitepapers/pagevisibility">Google Developers: Using the Page Visibility API</a></li>
</ol>
<p>（话说 Google 的文档也是大部分抄自 MDN 的，哈哈）</p>
<h2 id="最后">最后</h2><p>别看着看着忘了 Page Visibility 的初衷哦。一般情况下我们用不着，当需要性能优化，特别是要节省资源占用时，通过 Page Visibility 的状态来调整代码执行是非常非常有必要的。</p>
<p>文 / 玉伯</p>
<p>题图：可爱的龙猫，在思考什么是可见的，什么是不可见的。</p>
<p>附语：技术文如我所料，鲜有人回复。某个口头表扬我的同学，也别吝啬文字哦，否则……</p>
<hr>
<p>欢迎订阅 WTP（Web 技术与产品交流）微信公众帐号。WTP 关注技术、产品、自由梦，在每个工作日（偶尔休息日）会定期推送一篇原创文字。欢迎扫描二维码订阅：</p>
<p><img src="http://ww4.sinaimg.cn/thumbnail/68361562gw1e2iehwolnpj.jpg" alt=""></p>
</div>

    <div class="cat">
    
    <p><span>#</span> <a href="/category/blog/">blog</a></p>
    
    </div>

    <div class="relate">
        
        
        <p><span>PREV: </span><a rel="prev" href="/posts/14442226.html">Page Visibility 的 API 设计</a></p>
        

        
        
        <p><span>NEXT: </span><a rel="next" href="/posts/14360604.html">正则表达式中的向后匹配</a></p>
        

        <p><span></span><a rel="all" href="/">View All Posts</a></p>
    </div>

    <div class="comments">
        <div id="disqus_thread"></div>
    </div>

</div>


<div class="footer">
    <div class="center">
        AcyOrt / powered by <a target="_blank" href="https://github.com/AcyOrt/acyort">AcyOrt</a> / <a target="_blank" href="/rss.xml">RSS</a>
    </div>
</div>

<script>

var menu = document.querySelector('.menu');

document.querySelector('.main').addEventListener('click', function(e) {
    if (e.target.classList.toString().indexOf('menuicon') > -1) {
        return menu.classList.toggle('active')
    } 

    return menu.classList.remove('active')
})

</script>




<script>
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//acyort.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>



</div>

</body>
</html>
