<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="keywords" content="acyort, nodejs, blog" />
<meta name="description" content="A Node.js blog tool powered by GitHub." />
<link rel="icon" href="/icon.png" />
<link rel="stylesheet" href="/css/style.css" />

  <title>
我心目中的优秀 API - AcyOrt
</title>
</head>

<body>

<div class="main">

<div class="header">
    <div class="center">
        <a class="logo" href="/">AcyOrt</a>

        <div class="menu">
            <div class="menuicon"></div>

            <div class="menuitem">
            
            <a href="/">home</a>
            
            <a href="/about">about</a>
            
            <a href="/">archives</a>
            
            </div>
        </div>
    </div>
</div>




<div id="post" class="center">

    <p class="time">March 12, 2013</p> 

    <h1 class="title">我心目中的优秀 API</h1>

    <div class="content"><p>延续大前天的话题，陈皓在微博中提到</p>
<blockquote>
<p>【如何设计JS API？】我觉得有两点各个前端工程需要认真考虑：1）我们的一些 API 最好支持批量数据处理，而不是让人一次一次地调用。2）我们需要考虑多个 API 间的关联性，如果别人有可能在调用 API2 之前需要 API1 的结果，那么我们应该把 API1 和 API2 包一下。这会降低使用方的工作量。</p>
</blockquote>
<h2 id="支持批量处理">支持批量处理</h2><p>陈皓提到的这两点非常具体。支持批量处理，是 API 在设计时需要考虑多个输入。比如 shell 中的 cp 命令：</p>
<pre><code>$ cp *<span class="hljs-selector-class">.js</span> target_dir
</code></pre><p>对于 loader 来说也一样：</p>
<pre><code class="lang-js"><span class="hljs-comment">// 加载一个文件</span>
seajs.<span class="hljs-keyword">use</span>(<span class="hljs-symbol">'a</span>', callback)

<span class="hljs-comment">// 加载多个文件</span>
seajs.<span class="hljs-keyword">use</span>([<span class="hljs-symbol">'a</span>', <span class="hljs-symbol">'b</span>'], callback)
</code></pre>
<p>API 是否支持批量处理，得具体看是什么功能，比如 Node.js 中的读取文件接口：</p>
<pre><code class="lang-js">fs.readFile(<span class="hljs-string">'/etc/passwd'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, data)</span> </span>{
  <span class="hljs-comment">// do something</span>
});
</code></pre>
<p>这个 readFile 就没必要支持批量读取。</p>
<p>什么样的 API，以及什么时候需要支持批量处理呢？我觉得有以下几个规律：</p>
<ol>
<li><p><strong>直接面向普通使用者。</strong>比如 shell 中的好多命令，以及 <code>seajs.use</code>、<code>jQuery(selector)</code> 等等。这些 API 一般来说不用再封装，是高级 API。</p>
</li>
<li><p><strong>批量处理本身有含义、是常见需求。</strong>比如 readFile 支持批量价值就不大，一次读取多个文件的需求不常见，出现了也很容易基于 readFile 自己去实现。</p>
</li>
<li><p><strong>批量处理时，顺序无关，不存在依赖性。</strong>比如 cp 多个文件时，先处理哪个文件是没关系的。<code>seajs.use</code> 加载多个文件时，先加载同一层级的哪个文件也不应该影响最终结果。</p>
</li>
</ol>
<p>能满足以上需求的 API，经常就需要支持批量处理。</p>
<h2 id="考虑-api-的关联性">考虑 API 的关联性</h2><p>这个说的其实是依赖，很大程度上属于 user-land 范畴，API 本身经常很难做什么。比如在 shell 上，可以通过管道来解决依赖：</p>
<pre><code>$ cat sea-<span class="hljs-built_in">debug</span>.<span class="hljs-keyword">js </span><span class="hljs-title">| wc -l</span>
</code></pre><p>上面通过管道先后执行两个命令，可得到 <code>sea-debug.js</code> 文件的代码行数。</p>
<p>依赖问题最终都是顺序问题，shell 通过管道将依赖转换成单向顺序来解决，很轻巧方便。</p>
<p>但在浏览器端，异步满天飞，问题往往就没那么简单了。</p>
<p>比如</p>
<pre><code class="lang-js">seajs.<span class="hljs-keyword">use</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>], callback)
</code></pre>
<p>如果模块 b 依赖模块 a，模块 c 是独立的。那么我们面临的问题是：</p>
<ol>
<li>seajs 如何知道依赖信息？如何知道模块 b 是依赖模块 a 的？谁来告知？何时告知？</li>
<li>如何实现 a、b、c 三个模块同时并行加载，但执行时是按照依赖顺序来执行的？</li>
</ol>
<p>涉及异步、涉及依赖，都绕不开以上问题。在 YUI3、Dojo、RequireJS、SeaJS、OzJS 等等类库 / 框架中都需要解决以上问题。</p>
<p>对于依赖信息的获取，典型的处理方式有两种：</p>
<ol>
<li><p><strong>提前申明依赖信息</strong>。比如 YUI 里，对于自带模块，会有一个很大的 json 数据来声明各个模块之间的依赖。非自带模块，则需要在使用前先注册一下，注册时申明好依赖。这样，处理起来就简单了。</p>
</li>
<li><p><strong>自我携带依赖信息</strong>。各个模块的依赖，在模块自己的代码中申明，比如</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">(<span class="hljs-string">'b'</span>, [<span class="hljs-string">'a'</span>], factory)</span></span>
</code></pre>
<p>上面的第二个数组参数，表示模块 b 的依赖是模块 a.</p>
</li>
</ol>
<p>有了依赖信息后，就可以转换成顺序问题。依赖先加载，加载并执行后，再加载后续模块。这是最简单的处理方式。</p>
<p>还有一种方式是，因为依赖影响的是执行顺序，因此加载依旧可以并行，通通并行下载好后，在真正执行时，才根据依赖信息按顺序执行。这是 SeaJS 等 loader 的处理方式。</p>
<p>比如对于陈皓的那道面试题，如果用 SeaJS 来解决，可以：</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> API_URL = <span class="hljs-string">'http://coolshell.cn/t.php?callback=define&amp;n='</span>
<span class="hljs-keyword">var</span> urls = []

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">31</span>; i++) {
  urls.push(API_URL + i)
}

seajs.use(urls, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">31</span>; i++) {
    <span class="hljs-built_in">console</span>.log(i, <span class="hljs-built_in">arguments</span>[i - <span class="hljs-number">1</span>])
  }
})
</code></pre>
<p>并发请求和顺序输出都解决了。注意这里的依赖仅仅是最后的顺序输出，与普通的依赖是不同的。普通的模块之间的依赖，可以通过模块之间声明依赖关系来解决。</p>
<p>各种 loader 仅是解决文件加载、文件依赖。如何处理依赖是更宽泛的话题，这里就不多说了。</p>
<h2 id="我心目的优秀-api">我心目的优秀 API</h2><p>以上说的，纯粹是从陈皓的微博引发的一些点上的思考，不具有普适性。对大部分前端 API 设计来说，参考价值也很有限。</p>
<p>下面扯扯更宽层面上，我心目中优秀 API 的标准。</p>
<h3 id="简单">简单</h3><p>我想了很久，依旧想把“简单”摆在第一位。好的 API 必须是简单的。简单不仅仅是看起来简单，简单还意味着背后的实现逻辑是正常人类思路能理解的。比如</p>
<pre><code><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'string'</span>)
</code></pre><p>这个 API 是个前端都能看懂，并且能大概猜出背后是怎么实现的。虽然很可能猜错，但没关系，关键是你不会觉得神秘难懂。类似的，有很多实物 API：</p>
<blockquote>
<p>汽车车窗的控制把手。往上提就是关窗，往下摁就是开窗。很符合直觉，大概也能猜出是怎么实现的（当然实际没那么简单，但能让用户感觉很简单）。</p>
</blockquote>
<p>简单也意味着一致性。比如 JavaScript 里，forEach、map、filter 等所有数组遍历操作，callback 接收的参数都是 item、index、array. 这种一致性可以让你触类旁通，非常舒适。</p>
<h3 id="完备">完备</h3><p>完备是指，某个类库或框架，对所解决的问题领域和业务需求，要有彻底的深入理解。提供的 API 是一整套的，能处理该问题领域的各种可能性，各种实际需求。</p>
<p><strong>要达到完备性，首先要解决的是定位问题。</strong>任何类库框架都不可能解决所有问题，必须要非常清楚要解决的问题范畴。依旧拿我最爱的 jQuery 来举例。</p>
<p>jQuery 的定位非常清晰： <strong>DOM 操作类库</strong>，包括 DOM 操作、事件、动画和 Ajax。其他的比如 Cookie 操作、Loader 等功能，即便用户需求很旺盛，jQuery 也会节制欲望，不去涉足。</p>
<p>在这个定位下，jQuery 的设计也非常清晰： <strong>找到 DOM 元素，并操作它。</strong> 这样，jQuery 的整套 API 变得很优美：</p>
<pre><code class="lang-js">$(selector).attr(<span class="hljs-params">...</span>)
$(selector).css(<span class="hljs-params">...</span>)
$(selector).animate(<span class="hljs-params">...</span>)
<span class="hljs-params">...</span>
</code></pre>
<p>优美之处在于，你能想到的常用 DOM 操作等功能，jQuery 都提供了。不怎么常用的，使用 jQuery 的现有 API，也能快速实现。</p>
<p>这就是 API 的完备性，让你不会因为某些功能的实现而抓狂。一切都在那里静静躺着，等着你去发现，等着你去欣赏。</p>
<p>同样，SeaJS 也是抱着这个目的去做。SeaJS 的定位是 Web 端的模块加载器，核心是解决模块定义、依赖管理、模块加载。此外一切问题都不属于 SeaJS 范畴。 <strong>SeaJS 的理想是把自己做“死”</strong>，“死”意味着完备性，意味着站在 loader 的角度，SeaJS 的功能能增无可增，减无可减。</p>
<p>除了简单、完备这两个关键词，我想不到优秀的 API 还需要去做什么。简单能给用户带去欢喜，完备则可以让开发者去挑战新的领域。</p>
<h2 id="最后">最后</h2><p>有人反馈 WTP 的文章太技术，看不太懂。这个不好意思，这就是一个技术型的公众帐号，偶尔会谈谈产品。如果你不是做技术的，可以退订下，没关系的。</p>
<p>还有人反馈 WTP 上好多广告。这个，真没有哦。的确提到了 SeaJS，以后还会进一步说说 Arale 的一些东西。说这些，更多是因为我熟悉，分析熟悉的东西总会更有底气，也会更有料些。</p>
<p>大家可以回复，说说想看哪些内容，也可以问些具体的问题（不要问怎么学好 JavaScript 等大问题）。好的问题，我会仔细回复。</p>
<p>（完）</p>
<p>欢迎订阅 WTP（Web 技术与产品交流）微信公众帐号。WTP 在每个工作日（偶尔休息日）会定期推送一篇原创文字。请搜索 WTP 关键字，或扫描二维码订阅：</p>
<p><img src="http://ww4.sinaimg.cn/thumbnail/68361562gw1e2iehwolnpj.jpg" alt=""></p>
</div>

    <div class="cat">
    
    <p><span>#</span> <a href="/category/blog/">blog</a></p>
    
    </div>

    <div class="relate">
        
        
        <p><span>PREV: </span><a rel="prev" href="/posts/11974787.html">互联网时代的时间管理</a></p>
        

        
        
        <p><span>NEXT: </span><a rel="next" href="/posts/11878823.html">聊聊 JSONP 的 P</a></p>
        

        <p><span></span><a rel="all" href="/">View All Posts</a></p>
    </div>

    <div class="comments">
        <div id="disqus_thread"></div>
    </div>

</div>


<div class="footer">
    <div class="center">
        AcyOrt / powered by <a target="_blank" href="https://github.com/AcyOrt/acyort">AcyOrt</a> / <a target="_blank" href="/rss.xml">RSS</a>
    </div>
</div>

<script>

var menu = document.querySelector('.menu');

document.querySelector('.main').addEventListener('click', function(e) {
    if (e.target.classList.toString().indexOf('menuicon') > -1) {
        return menu.classList.toggle('active')
    } 

    return menu.classList.remove('active')
})

</script>




<script>
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//acyort.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>



</div>

</body>
</html>
