<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="keywords" content="acyort, nodejs, blog" />
<meta name="description" content="A Node.js blog tool powered by GitHub." />
<link rel="icon" href="/icon.png" />
<link rel="stylesheet" href="/css/style.css" />

  <title>
Sea.js 源码解析（三） - AcyOrt
</title>
</head>

<body>

<div class="main">

<div class="header">
    <div class="center">
        <a class="logo" href="/">AcyOrt</a>

        <div class="menu">
            <div class="menuicon"></div>

            <div class="menuitem">
            
            <a href="/">home</a>
            
            <a href="/about">about</a>
            
            <a href="/">archives</a>
            
            </div>
        </div>
    </div>
</div>




<div id="post" class="center">

    <p class="time">July 30, 2013</p> 

    <h1 class="title">Sea.js 源码解析（三）</h1>

    <div class="content"><p><img src="https://f.cloud.github.com/assets/97227/876112/4ba141d0-f8ba-11e2-8b6d-4eabd4af4434.jpg" alt="789px-mallard2"></p>
<p>前一篇解析中，关于 undefined 的讨论挺有意思。jQuery 2.x 里，很可能会去掉这种写法。有兴趣的可以去看下<a href="https://github.com/lifesinger/lifesinger.github.com/issues/171">原文评论</a>。</p>
<p>今天继续源码解析，说说 util-lang.js 文件。</p>
<h2 id="语言增强">语言增强</h2><p>util-lang.js 经历丰富，一生大起大落，辉煌时有好几百行，到如今只剩下十几行。</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isType</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">"[object "</span> + type + <span class="hljs-string">"]"</span>
  }
}

<span class="hljs-keyword">var</span> isObject = isType(<span class="hljs-string">"Object"</span>)
<span class="hljs-keyword">var</span> isString = isType(<span class="hljs-string">"String"</span>)
<span class="hljs-keyword">var</span> isArray = <span class="hljs-built_in">Array</span>.isArray || isType(<span class="hljs-string">"Array"</span>)
<span class="hljs-keyword">var</span> isFunction = isType(<span class="hljs-string">"Function"</span>)

<span class="hljs-keyword">var</span> _cid = <span class="hljs-number">0</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cid</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> _cid++
}
</code></pre>
<p>辉煌时的几百行，提供了各种功能，今天暂且不表，以后有机会再说。剩下的功能，明眼人一看就明白，一个是类型判断，另一个 cid 生成器。先聊聊前者。</p>
<h2 id="类型判断">类型判断</h2><p>以 isString 为例，这个故事不太复杂，也不那么简单。各位看官泡杯凉茶，听我道来。</p>
<p>判断一个变量是否字符串类型，最简单直接的写法是</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isString</span><span class="hljs-params">(obj)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj == <span class="hljs-string">"string"</span>
}
</code></pre>
<p>绝大部分情况下，以上代码就够用了。然而</p>
<pre><code class="lang-js"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"xxx"</span>) <span class="hljs-comment">// =&gt; "object"</span>
</code></pre>
<p>当字符串是通过 <code>new String</code> 生成时，typeof 返回的是 <code>&quot;object&quot;</code>，因为 <code>new String</code> 返回的的确是对象。可以参考这篇总结文：<a href="http://blog.alexanderdickson.com/javascript-typeof">JavaScript&#39;s typeof operator</a> 。</p>
<p>但我们才不管是字符串直接量，还是字符串对象呢，我们希望这两种情况下，isString 都能返回 <code>true</code> 。于是</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj == <span class="hljs-string">"string"</span> || obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>
}
</code></pre>
<p>上面的写法，曾出现在各种流行类库的早期代码中，一直工作得好好的。直到有人在 iframe 中，写出以下代码</p>
<pre><code class="lang-js"><span class="hljs-comment">// 在 iframe 中</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"bar"</span>)

<span class="hljs-keyword">if</span> (top.isString(foo)) {
  <span class="hljs-comment">// Do some cool things</span>
}
</code></pre>
<p>上面的代码，是调用父页面的 isString 方法，来判断 iframe 中的变量是否字符串。由于 iframe 和 top 中的 String 全局对象并不相等，因此 <code>obj instanceof String</code> 会返回 <code>false</code>，于是 <code>top.isString(foo)</code> 华丽丽地挂了。</p>
<p>做前端真苦逼，但不能因为苦逼就撂挑子不干了。全世界范围内开始为这一「难题」想尽各种办法，后来有神人出山，轻松给出一段代码</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) == <span class="hljs-string">"[object String]"</span>
}
</code></pre>
<p>此代码一出，天下震惊，引各路类库竞折腰。这代码，可不仅仅解决了 isString 的问题，而是解决了 isXxx 一类问题。</p>
<p>神码原理很简单。简言之，是因为 ECMAScript 就是这么规定的，而各个浏览器都遵守了这一规定，因此就有了这一统天下的写法。有兴趣的，可以看这篇文章：<a href="http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/">instanceof considered harmful (or how to write a robust isArray)</a> 。</p>
<p>下面说说另一端辛酸史。</p>
<h2 id="鸭子判断">鸭子判断</h2><p>在神码出现前，isString 的问题还好说，甚至可以忽略，但 isArray、isFunction、isRegExp 等函数的问题更大，而且很难忽略。我们拿 isArray 来说说。</p>
<pre><code class="lang-js">typeof <span class="hljs-string">[]</span> // =&gt; <span class="hljs-string">"object"</span>
</code></pre>
<p>不要去责怪 typeof，它没错。JavaScript 里，数组就是对象。</p>
<pre><code class="lang-js">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>instanceof 还是挺不错的，但和 isString 一样，遇到跨页面操作时，就不行。和 isString 还不一样，对于 isArray 来说，这个问题更严重。（想想为什么？）</p>
<p>于是大家想起了一句谚语</p>
<blockquote>
<p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.
如果它看起来像鸭子，会像鸭子一样游泳，也会嘎嘎叫，那么它很可能就是一只鸭子。</p>
</blockquote>
<p>比如题图中的动物，大部分人会猜这是一只鸭子。</p>
<p>人类的大脑，对世界的认识里，往往就是鸭子逻辑。这没什么不对，绝大部分情况下都运作良好。题图中的动物的确是只鸭子，我们的判断是对的。</p>
<p>这样，放到代码里，就有了</p>
<pre><code class="lang-js"><span class="hljs-function">function <span class="hljs-title">isArray</span>(<span class="hljs-params"><span class="hljs-keyword">object</span></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">object</span> === <span class="hljs-string">"object"</span> &amp;&amp;
    <span class="hljs-string">'splice'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span> &amp;&amp; <span class="hljs-string">'join'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>
}
</code></pre>
<p>上面的代码，在 Prototype 类库中真实存在过。直到神码出现后，才改成以下写法</p>
<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(obj) {
  <span class="hljs-keyword">return</span> <span class="hljs-type">Object.prototype.toString.call(obj)</span> === <span class="hljs-string">"[object Array]"</span>
}
</code></pre>
<p>对现代浏览器来说，上面的写法，依旧让各大浏览器引擎的实现者觉得很难受，于是直接有了</p>
<pre><code class="lang-js"><span class="hljs-built_in">Array</span>.<span class="hljs-built_in">isArray</span>([]) <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>Array 对象中直接有了 isArray 静态方法。当年的详情：<a href="http://web.mit.edu/jwalden/www/isArray.html">Determining with absolute accuracy whether or not a JavaScript object is an array</a> 。</p>
<p>可惜目前只有 isArray 方法，isFunction、isRegExp 等，依旧得靠我们自己去实现。</p>
<h2 id="放在一起">放在一起</h2><p>看完了前人的辛酸史，我们直接拿来用就好。最简单的拿法是</p>
<pre><code class="lang-js">var toString = Object.prototype.toString

<span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(obj) {
  <span class="hljs-keyword">return</span> <span class="hljs-type">toString.call(obj)</span> === <span class="hljs-string">"[object Object]"</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(obj) {
  <span class="hljs-keyword">return</span> <span class="hljs-type">toString.call(obj)</span> === <span class="hljs-string">"[object String]"</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(obj) {
  <span class="hljs-keyword">return</span> <span class="hljs-type">toString.call(obj)</span> === <span class="hljs-string">"[object Array]"</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span>(obj) {
  <span class="hljs-keyword">return</span> <span class="hljs-type">toString.call(obj)</span> === <span class="hljs-string">"[object Function]"</span>
}
</code></pre>
<p>在绝大部分代码里，上面这样写，已经很完美。但在 jQuery 或 Sea.js 等类库代码里，考虑压缩后的大小，依旧可以改进</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">type</span>(<span class="hljs-params"> obj </span>) </span>{
  <span class="hljs-keyword">if</span> ( obj == <span class="hljs-literal">null</span> ) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>( obj );
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">"object"</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">"function"</span> ?
      class2type[ core_toString.call(obj) ] || <span class="hljs-string">"object"</span> :
      <span class="hljs-keyword">typeof</span> obj;
}
</code></pre>
<p>上面是 jQuery 里的写法，有兴趣的可以去研读下。特别是我没提及的 isObject 和 isFunction，这两个历史更曲折悠长，衍生讨论很多。</p>
<p>Sea.js 里，只做了个简单封装</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isType</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">"[object "</span> + type + <span class="hljs-string">"]"</span>
  }
}
</code></pre>
<p>isType 是个返回函数的函数，这样就可以用来生成 isString 等各种方法。这写法主要是为了减少压缩后的大小，不是为了故意耍酷。耍酷的代码要尽量少，要见一个杀一个。</p>
<p>在 Sea.js 里就这么着了，是因为在 Sea.js 的使用场景下，isXxx 都是内部方法，调用处是可预测的，因此无需像 jQuery 那样考虑各种各样场景。</p>
<h2 id="cid-生成">cid 生成</h2><p>util-lang.js 里，还有一段代码</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> _cid = <span class="hljs-number">0</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cid</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> _cid++
}
</code></pre>
<p>cid 代表的是 client id，一般还会有</p>
<ol>
<li>uuid - 全宇宙唯一 id 。</li>
<li>uid - 唯一 id 。</li>
<li>cid - 在客户端保持唯一的 id 。</li>
</ol>
<p>在 Sea.js 的场景下，cid 就足够用了。在够用的情况下，尽量保持简单，这是 Sea.js 的源码追求。</p>
<h2 id="最后">最后</h2><p>上面的故事，在 JavaScript 开发中，算是很小很小的插曲。但每每回顾，依旧心生敬畏。 <strong>对正确性和简单性的追求，是优秀程序员心中的「根因」</strong> ，有了这根，才有了繁花似锦的各种代码。</p>
<p>最后，留几个小作业：</p>
<ol>
<li><p>我们知道 <code>typeof new String(&quot;xxx&quot;)</code> 返回 &quot;object&quot;，请问 <code>typeof String(&quot;xxx&quot;)</code> 返回什么？为什么？</p>
</li>
<li><p>为什么我用的是 <code>typeof obj == &quot;string&quot;</code> 而不是 <code>typeof obj === &quot;string&quot;</code> ？</p>
</li>
<li><p>下面这种写法，有什么不妥？</p>
<pre><code class="lang-js">   <span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(obj) {
     <span class="hljs-keyword">return</span> <span class="hljs-type">obj.constructor</span> === String
   }
</code></pre>
</li>
<li><p><code>Object.prototype.toString.call(obj)</code> 和 <code>({}).toString.call(obj)</code> 的区别是什么？哪个好？</p>
</li>
<li><p>鸭子判断究竟好不好？那些异常情况，真的需要关注吗？</p>
</li>
</ol>
<p>以上 5 个问题，当回复里都有思考过的回答后，我再更新 Sea.js 源码解析（四）。WTP 的更新频率，取决于大家的参与程度，靠大家了:)</p>
<p>（完）</p>
<p>题图：并不简单的鸭子。</p>
<hr>
<p>欢迎订阅 WTP（Web 技术与产品交流）微信公众帐号。WTP 关注技术、产品、自由梦，会偶尔推送一些原创文字。欢迎扫描二维码订阅：</p>
<p><img src="http://ww4.sinaimg.cn/thumbnail/68361562gw1e2iehwolnpj.jpg" alt=""></p>
</div>

    <div class="cat">
    
    <p><span>#</span> <a href="/category/blog/">blog</a></p>
    
    </div>

    <div class="relate">
        
        
        <p><span>PREV: </span><a rel="prev" href="/posts/18733290.html">又是一年校招时</a></p>
        

        
        
        <p><span>NEXT: </span><a rel="next" href="/posts/17312011.html">几部老电影</a></p>
        

        <p><span></span><a rel="all" href="/">View All Posts</a></p>
    </div>

    <div class="comments">
        <div id="disqus_thread"></div>
    </div>

</div>


<div class="footer">
    <div class="center">
        AcyOrt / powered by <a target="_blank" href="https://github.com/AcyOrt/acyort">AcyOrt</a> / <a target="_blank" href="/rss.xml">RSS</a>
    </div>
</div>

<script>

var menu = document.querySelector('.menu');

document.querySelector('.main').addEventListener('click', function(e) {
    if (e.target.classList.toString().indexOf('menuicon') > -1) {
        return menu.classList.toggle('active')
    } 

    return menu.classList.remove('active')
})

</script>




<script>
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//acyort.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>



</div>

</body>
</html>
