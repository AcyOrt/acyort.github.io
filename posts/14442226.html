<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="keywords" content="acyort, nodejs, blog" />
<meta name="description" content="A Node.js blog tool powered by GitHub." />
<link rel="icon" href="//icon.png" />
<link rel="stylesheet" href="/css/style.css" />

  <title>
Page Visibility 的 API 设计 - AcyOrt
</title>
</head>

<body>

<div class="main">

<div class="header">
    <div class="center">
        <a class="logo" href="/">AcyOrt</a>

        <div class="menu">
            <div class="menuicon"></div>

            <div class="menuitem">
            
            <a href="/">home</a>
            
            <a href="/">about</a>
            
            <a href="/">archives</a>
            
            </div>
        </div>
    </div>
</div>




<div id="post" class="center">

    <p class="time">May 17, 2013</p> 

    <h1 class="title">Page Visibility 的 API 设计</h1>

    <div class="content"><p><img src="https://f.cloud.github.com/assets/97227/516911/24a86808-beca-11e2-991e-559d8fe0e4ed.jpg" alt="d1a014252bf0dea30fad26f081ea0643"></p>
<p>昨天的文章发出时，有一处严重错误：</p>
<blockquote>
<p>document.hidden 是布尔值，true 表示页面可见，false 表示不可见。</p>
</blockquote>
<p>有意思的是，这个错误如此严重，但却只有 2 个人发现并回复给我。这个小故事背后，可以看到：</p>
<ol>
<li>人类大脑的纠错本领特别强。如果你到现在还不知道错在哪，说明你的大脑超强。</li>
<li>为什么我会犯这个错呢？是我的问题，还是 document.hidden 设计不人性？</li>
</ol>
<p>人类大脑太复杂高深，在此就不研究了。我们从 API 设计层面来说说一些有意思的事情。</p>
<h2 id="向后兼容">向后兼容</h2><p>为什么要是 document.hidden，而不是 document.visible？如果设计成 document.visible，那么 true 表示可见，false 表示不可见，是多么自然的事情啊。</p>
<p>我们从代码使用上入手来想想。如果设计成 document.visible，很容易写出：</p>
<pre><code class="lang-js"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.visible) {
  <span class="hljs-comment">// 页面可见时的正常逻辑</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 页面不可见时，减少点资源占用</span>
}
</code></pre>
<p>上面的代码初看没什么问题，但作为前端，眼尖一点不难发现是有问题的：</p>
<p><strong>在尚不支持 Page Visibility API 的浏览器中，document.visible 的值是 undefined.</strong></p>
<p>为了让代码在老浏览器里也没问题，一种可行的写法是：</p>
<pre><code class="lang-js"><span class="hljs-comment">// 在老浏览器上，始终判定页面为可见</span>
<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">document</span>.visible === <span class="hljs-string">'undefined'</span> || <span class="hljs-built_in">document</span>.visible === <span class="hljs-literal">true</span>) {
  <span class="hljs-comment">// 页面可见时的正常逻辑</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 页面不可见时，减少点资源占用</span>
}
</code></pre>
<p>上面这种写法，需要一定经验才能写出来。否则稍不留意，就会掉坑里。</p>
<p>如果设计成 document.hidden，则一切简单多了：</p>
<pre><code class="lang-js"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.hidden) {
  <span class="hljs-comment">// 页面不可见时，减少点资源占用</span>
}
</code></pre>
<p>老浏览器上，document.hidden 取值为 undefined，可以当做布尔值 false 来使用。</p>
<p>这是 API 设计上的一种向后兼容。给任何现有体系增加新接口，都需要仔细考虑场景，做到向前的功能增强，同时向后也能合理兼容。</p>
<h2 id="可扩展性">可扩展性</h2><p>还有一个接口是：</p>
<pre><code><span class="hljs-built_in">document</span>.visibilityState
</code></pre><p>规范中明确可取的值是：visible、hidden、prerender、unloaded</p>
<p>作为枚举值，最大的好处是，可以方便增加新状态。比如页面所在浏览器窗口被其他窗口完全遮挡住时，visibilityState 的取值可以是 obscured. 虽然目前没有这个状态值，但未来如果真的有需求，就可以很方便添加上。</p>
<p>这是 API 可扩展性设计中很小的一个点，优美往往隐藏在细节里。</p>
<h2 id="一致性">一致性</h2><p>最后想说的接口是 visibilityState 属性值发生变化时的事件：visibilitychange 。</p>
<p>为什么不是 visibilityChange? 或 change:visibility 等命名？</p>
<p>命名永远是计算机科学里的两大难题之一。</p>
<p>对于前端来说，下面这些 DOM 事件不应该陌生：</p>
<pre><code><span class="hljs-built_in">mousedown</span>
<span class="hljs-built_in">mousemove</span>
keypress
keyup
touchstart
dragleave
readystatechange
propertychange
</code></pre><p>有了上面这些事件名作为参考，visibilitychange 看着就非常舒服了。</p>
<p>舒服是因为习惯，是因为一致。看似简单的命名，真心不简单。</p>
<h2 id="小结">小结</h2><p>向后兼容、可扩展性、一致性，这是 API 设计时经常要考虑的三个方面。Page Visibility 看似简单，着实不简单。</p>
<p>还有规范化的思维和做事方式，也非常值得我们学习。国内经常只有问题的解决，却缺了规范的沉淀，导致很多问题虽然能解决掉，但却很难传播推广开来。</p>
<p>历史的仓库里，藏着多少泪。</p>
<p>文 / 玉伯</p>
<p>题图：依旧是可爱的龙猫，看不明白高楼大厦里的人类，究竟在忙活什么。</p>
<p>最后，两个小思考留给大家：</p>
<ol>
<li>DOM 事件名，大部分都被设计成小写单词直接拼起来（比如 keypress、readystatechange），这是出于什么考虑？</li>
<li>在 DOM 事件中，Mutation 类事件名，是驼峰风格（比如 DOMNodeInserted），这又是为什么呢？</li>
</ol>
<p>期待大家的思考与回复，成长就在参与中。</p>
<hr>
<p>欢迎订阅 WTP（Web 技术与产品交流）微信公众帐号。WTP 关注技术、产品、自由梦，在每个工作日（偶尔休息日）会定期推送一篇原创文字。欢迎扫描二维码订阅：</p>
<p><img src="http://ww4.sinaimg.cn/thumbnail/68361562gw1e2iehwolnpj.jpg" alt=""></p>
</div>

    <div class="cat">
    
    <p><span>#</span> <a href="/category/blog/">blog</a></p>
    
    </div>

    <div class="relate">
        
        
        <p><span>PREV: </span><a rel="prev" href="/posts/16632814.html">习惯与变化</a></p>
        

        
        
        <p><span>NEXT: </span><a rel="next" href="/posts/14406696.html">Page Visibility 初探</a></p>
        

        <p><span></span><a rel="all" href="/">VIEW ALL POSTS</a></p>
    </div>

    <div class="comments">
        <div id="disqus_thread"></div>
    </div>

</div>


<div class="footer">
    <div class="center">
        made by AcyOrt / powered by <a target="_blank" href="https://github.com/AcyOrt/acyort">AcyOrt</a> / <a target="_blank" href="/rss.xml">RSS</a>
    </div>
</div>

<script>

var menu = document.querySelector('.menu');

document.querySelector('.main').addEventListener('click', function(e) {
    if (e.target.classList.toString().indexOf('menuicon') > -1) {
        return menu.classList.toggle('active')
    } 

    return menu.classList.remove('active')
})

</script>




<script>
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//acyort.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>



</div>

</body>
</html>
