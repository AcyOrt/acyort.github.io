<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="keywords" content="acyort, nodejs, blog" />
<meta name="description" content="A Node.js blog tool powered by GitHub." />
<link rel="icon" href="/icon.png" />
<link rel="stylesheet" href="/css/style.css" />

  <title>
简单还是一致（续） - AcyOrt
</title>
</head>

<body>

<div class="main">

<div class="header">
    <div class="center">
        <a class="logo" href="/">AcyOrt</a>

        <div class="menu">
            <div class="menuicon"></div>

            <div class="menuitem">
            
            <a href="/">home</a>
            
            <a href="/about">about</a>
            
            <a href="/">archives</a>
            
            </div>
        </div>
    </div>
</div>




<div id="post" class="center">

    <p class="time">April 04, 2013</p> 

    <h1 class="title">简单还是一致（续）</h1>

    <div class="content"><p><img src="https://f.cloud.github.com/assets/97227/351057/0cfbcdb2-a039-11e2-8ecb-044d40aa8b83.jpg" alt="1013990952e91f73aa"></p>
<p>前不久发了一篇文章：<a href="https://github.com/lifesinger/lifesinger.github.com/issues/139">简单还是一致</a>，引起了不少热议。淘宝前端工程师拔赤就此总结了一篇文章，非常值得思辩。全文如下。</p>
<hr>
<h2 id="一段代码的两种理解（1）">一段代码的两种理解（1）</h2><p>看这段代码：</p>
<pre><code class="lang-js">seajs.use(<span class="hljs-string">'a'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) </span>{
  A.doSth();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a'</span>);
});

<span class="hljs-comment">// some logic...</span>

seajs.use(<span class="hljs-string">'b'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">B</span>) </span>{
  B.doSth();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b'</span>);
});
</code></pre>
<p>问题来了，我们想象这段代码出现在淘宝首页，淘宝首页的结构是被分割为很多个“区块”，每个“区块”由不同业务线中的同学开发维护，他们之间互不知晓，最终首页是被“拼凑”而成的。那么这个例子中，若A的代码报错，会不会影响B的代码？</p>
<p>按照玉伯的设计，因为同步执行回调，当然会影响。怎么办？淘宝首页架构师要call正在休假的A让他去改<code>A.doSth()</code>的逻辑以适应seajs的简单性吗？</p>
<p>本来是一个小功能出问题，导致整个页面瘫痪掉，这种架构当然有问题。</p>
<p>这段代码真实的语义应当是：</p>
<pre><code class="lang-js">seajs.use(<span class="hljs-string">'a'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) </span>{
  A.doSth();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a'</span>);
}, {
  <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 异步执行callback</span>
})

<span class="hljs-comment">// some logic...</span>

seajs.use(<span class="hljs-string">'b'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">B</span>) </span>{
  B.doSth();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b'</span>);
}, {
  <span class="hljs-attr">async</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 同步执行callback</span>
})
</code></pre>
<p>seajs的“一致性”隐藏了这个重要的配置。</p>
<h2 id="一段代码的两种理解（2）">一段代码的两种理解（2）</h2><p>看这段代码：</p>
<pre><code class="lang-js">seajs.<span class="hljs-keyword">use</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, callback)
</code></pre>
<p>这段代码有两种理解</p>
<ul>
<li>我想依次执行<code>a.js</code>，<code>b.js</code>，<code>c.js</code>，这时a、b、c之间有依赖</li>
<li>我想尽快执行<code>a.js</code>、<code>b.js</code>、<code>c.js</code>的代码，三者无依赖</li>
</ul>
<p>对于第一种情况，三段代码的加载顺序无要紧，只要三者顺序执行即可，这和浏览器中写入script标签一样。</p>
<p>对于第二种情况，因为有“约定”三者无依赖，每段js代码加载完成后立即执行。</p>
<p><code>a.js</code>、<code>b.js</code>、<code>c.js</code>之间到底有无依赖，在这段代码中是看不出来的。其实上段代码的真实语义其实等同于</p>
<pre><code class="lang-js">seajs.<span class="hljs-keyword">use</span>(<span class="hljs-symbol">'a</span>', <span class="hljs-symbol">'b</span>', <span class="hljs-symbol">'c</span>', callback, {
  sequential: <span class="hljs-keyword">false</span> <span class="hljs-comment">// 不要顺序执行a,b,c</span>
});
</code></pre>
<p>问题又来了，seajs默认三者之间无依赖。如果真有呢？</p>
<p>同样，seajs的“一致性”隐藏了这个配置信息。</p>
<h2 id="小结">小结</h2><p>其实，代码所蕴含的信息，不会因为代码量减少而减少。代码过于简洁，就需要额外的“规约”来传达这些重要信息。</p>
<p>“黄金法则”中提到的“简单性”就是指约定，约定共识，做事才会简单。其中提到的“完整性”是指的底层机制的健壮，说的直白一点就是面向场景的设计。</p>
<p>这时，seajs就和旧有的类库有所不同，seajs提供“方法”和“思路”，而jquery、yui、mootools等则提供“工具”。两种思路直接决定了类库所面向的“问题集合”。因此，seajs需要“学习”，而jquery更多的则是需要“查阅”。</p>
<p>对于具体的场景来说，“一致”的约定难免单薄，相比之下，“工具”则更易于被大众接受。理论最终是要和业务结合，这也是为什么一个“懂”业务的框架看起来不美的原因。“懂业务”带来的复杂性和“强约定”带来的优雅的编程体验，两者之间，你会选择哪个？</p>
<p>（完）  文 / 拔赤</p>
<p>题图：很漂亮的三片叶子。对于叶子，你喜欢简单，还是一致？抑或复杂？</p>
<hr>
<p>欢迎订阅 WTP（Web 技术与产品交流）微信公众帐号。WTP 关注技术、产品、自由梦，在每个工作日（偶尔休息日）会定期推送一篇原创文字。欢迎扫描二维码订阅：</p>
<p><img src="http://ww4.sinaimg.cn/large/68361562gw1e2xqaox0asj.jpg" alt=""></p>
</div>

    <div class="cat">
    
    <p><span>#</span> <a href="/category/blog/">blog</a></p>
    
    </div>

    <div class="relate">
        
        
        <p><span>PREV: </span><a rel="prev" href="/posts/12967692.html">阿里前端的困局与突围</a></p>
        

        
        
        <p><span>NEXT: </span><a rel="next" href="/posts/12688281.html">简单还是一致</a></p>
        

        <p><span></span><a rel="all" href="/">View All Posts</a></p>
    </div>

    <div class="comments">
        <div id="disqus_thread"></div>
    </div>

</div>


<div class="footer">
    <div class="center">
        AcyOrt / powered by <a target="_blank" href="https://github.com/AcyOrt/acyort">AcyOrt</a> / <a target="_blank" href="/rss.xml">RSS</a>
    </div>
</div>

<script>

var menu = document.querySelector('.menu');

document.querySelector('.main').addEventListener('click', function(e) {
    if (e.target.classList.toString().indexOf('menuicon') > -1) {
        return menu.classList.toggle('active')
    } 

    return menu.classList.remove('active')
})

</script>




<script>
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//acyort.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>



</div>

</body>
</html>
