<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="keywords" content="acyort, nodejs, blog" />
<meta name="description" content="A Node.js blog tool powered by GitHub." />
<link rel="icon" href="//icon.png" />
<link rel="stylesheet" href="/css/style.css" />

  <title>
聊聊 JSONP 的 P - AcyOrt
</title>
</head>

<body>

<div class="main">

<div class="header">
    <div class="center">
        <a class="logo" href="/">AcyOrt</a>

        <div class="menu">
            <div class="menuicon"></div>

            <div class="menuitem">
            
            <a href="/">home</a>
            
            <a href="/">about</a>
            
            <a href="/">archives</a>
            
            </div>
        </div>
    </div>
</div>




<div id="post" class="center">

    <p class="time">March 11, 2013</p> 

    <h1 class="title">聊聊 JSONP 的 P</h1>

    <div class="content"><p>前天的文章 <a href="https://github.com/lifesinger/lifesinger.github.com/issues/117">放开你的思路</a>，微信和微博上得到了不少回复，陈皓也提到可以进一步探讨 JS API 的设计。API 的设计是一个很大的话题，今天延续前天的文章，仅聊聊 JSONP 的设计。</p>
<p>JSONP 是 JSON With Padding 的缩写。一个典型的 JSONP 请求如下</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://server.example.com/users/abc?callback=parseResponse"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>返回值为</p>
<pre><code class="lang-js">parseResponse({<span class="hljs-string">"name"</span>: <span class="hljs-string">"Foo"</span>, <span class="hljs-string">"id"</span>: <span class="hljs-number">1234</span>, <span class="hljs-string">"rank"</span>: <span class="hljs-number">7</span>})<span class="hljs-comment">;</span>
</code></pre>
<p>其中 <code>parseResponse</code> 是由 <code>callback</code> 参数指定的，也就是 JSONP 中的 P（adding）。这个 P 可不简单，第一个想到这么用的人，绝对是个大牛。因为有了这个 P，解决了好些难题：</p>
<ol>
<li><p><strong>回调问题</strong>。只要发出 script 请求，自动等待 callback 回调就好，并且精准得能秒杀 <code>onload</code> 等方案。</p>
</li>
<li><p><strong>跨域问题</strong>。因为浏览器的同源策略，跨域一直是前端的难题。跨域与安全息息相关，JSONP 没有破坏安全性，同时却具备了全面跨域能力。巧妙而实用。</p>
</li>
<li><p><strong>协作问题</strong>。后端专注与数据处理与输出，前端专注与数据展现。除了 JSON 数据本身的格式约定，其他约定仅仅需要一个 P 就好。</p>
</li>
</ol>
<p>好了，再说下去，估计很多人会不乐意了。JSONP 的劣势也很明显：</p>
<ol>
<li><p><strong>无中间状态</strong>。不像 XHR（XMLHttpRequest） 那样，有丰富的 status 、readyState 等属性，可以很精准地知道各种状态。</p>
</li>
<li><p><strong>只能 GET</strong>。不像 XHR 那样，可以全方位支持 GET、POST、PUT、DELETE。</p>
</li>
<li><p><strong>只能异步</strong>。XHR 是可以同步的，估计很多人没用过，同步其实是 XHR 的默认行为（省略 open 的第三个参数就代表同步）。</p>
</li>
</ol>
<p>本文不聊其他的，专注聊聊那个 P。</p>
<p>回到开头那个例子：</p>
<pre><code>http:<span class="hljs-regexp">//</span>server.example.com<span class="hljs-regexp">/users/</span>abc?callback=parseResponse
</code></pre><p><code>parseResponse</code> 是一个全局函数。当页面上很多 JSONP 请求时，就有可能出现很多全局函数。虽然全局变量并不一定是恶魔，但不好好管理的全局变量真的有可能成为恶魔。管理的方案之一是给 P 引入命名空间：</p>
<pre><code>http:<span class="hljs-regexp">//</span>server.example.com<span class="hljs-regexp">/users/</span>abc?callback=JSONP.parseResponse
</code></pre><p>这样，所有 JSONP 的回调处理函数就都有了根，可以避免与其他函数的潜在冲突。</p>
<p>可是，这还得绞尽脑汁给 <code>JSONP.xxx</code> 命名，经常大家会想到一块，比如 xxx 经常会不谋而合：</p>
<pre><code><span class="hljs-keyword">callback</span>
handle
parseData
_Callback
jsonp
</code></pre><p>这种不谋而合，虽然代表着英雄所见略同式的欣慰，但更多的是：我靠，你怎么也取这个名字？</p>
<p>这可怎么解决呢？</p>
<p>来试试 jQuery 类库。jQuery 的优秀绝对不仅仅是给你一个 $ 符号，jQuery 在很多方面考虑得非常周到：</p>
<pre><code class="lang-js">$.getJSON(<span class="hljs-string">"http://server.example.com/users/abc?callback=?"</span>,
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
    <span class="hljs-built_in">console</span>.log(data.name); <span class="hljs-comment">// =&gt; Foo</span>
  });
</code></pre>
<p>很神奇的，只需要指定下 <code>callback=?</code> 就好，再也不用为命名犯愁了。原理是 jQuery 帮你随机命名了一个当前页面唯一的全局 callback 函数，并且与 success 调用串接了起来。这样，就可以像使用 XHR 一样直接在回调中拿到 data 数据。</p>
<p>jQuery 再好，也抵挡不住 winter 等神人的不喜欢。这时，我们可以用各种 loader 来实现，比如：</p>
<pre><code class="lang-js">seajs.<span class="hljs-keyword">use</span>(<span class="hljs-string">"http://server.example.com/users/abc?callback=define"</span>,
  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span></span> {
    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">data</span>.<span class="hljs-keyword">name</span>); // =&gt; Foo
  });
</code></pre>
<p>通过 RequireJS、SeaJS、OzJS 等 XMD loader，我们也不再需要为回调函数名烦恼，只要给 callback 传入 define 就好。</p>
<p>如果你有全站使用 loader 方案，更进一步，可以约定没有传 callback 参数时，默认就是 define. 这意味着对于静态 JSON 数据来说，可以静态化：</p>
<pre><code class="lang-js">seajs.<span class="hljs-keyword">use</span>(<span class="hljs-string">"http://server.example.com/users/abc.js"</span>,
  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span></span> {
    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">data</span>.<span class="hljs-keyword">name</span>); // =&gt; Foo
  });
</code></pre>
<p>这样，服务端的 JSONP 数据直接可以是静态文件：</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">define</span></span>({<span class="hljs-string">"name"</span>: <span class="hljs-string">"Foo"</span>, <span class="hljs-string">"id"</span>: <span class="hljs-number">1234</span>, <span class="hljs-string">"rank"</span>: <span class="hljs-number">7</span>});
</code></pre>
<p>这带来的好处看起来很小，实际上很有用。因为这意味着数据可以提前处理好，可以提前缓存，甚至可以静态化存储到 CDN 上，可以缓存到用户浏览器上。静态化的好处，谁用谁知道。</p>
<p>用 define 固定住 callback 名，配合浏览器端的 loader，我们可以传输各种数据：</p>
<pre><code class="lang-js"><span class="hljs-selector-tag">define</span>([ ... ]); <span class="hljs-comment">// 数组格式，比如搜索提示数据</span>
<span class="hljs-selector-tag">define</span>(<span class="hljs-string">"...."</span>); <span class="hljs-comment">// 直接字符串，比如模板</span>
</code></pre>
<p>这个方案，鄙人很无耻，还申请过一个专利，叫 JSONM 协议，M 是 Module（模块）。不过以上用法不在专利保护内容里，大家可以放心大胆用。</p>
<p>P 还可以摇身一变，从 JSONP 变成 XHR，比如</p>
<pre><code>http://server.example.<span class="hljs-keyword">com</span>/users/<span class="hljs-keyword">abc</span>?<span class="hljs-built_in">type</span>=xhr
</code></pre><p>通过 type 参数，服务端就会直接返回 JSON 数据，这样就可用在 XHR 调用中。Google 的 API 中有类似的设计，很灵活。</p>
<p>JSONP 的这个 P，到此就谈完了。除了这个 P，更有挑战的是 JSON 数据本身的设计。这里面学问大了去，等有时间再细说。</p>
<p>有任何想法，欢迎回复，欢迎讨论。</p>
<p>（完）</p>
<p>欢迎订阅 WTP（Web 技术与产品交流）微信公众帐号。WTP 在每个工作日（偶尔休息日）会定期推送一篇原创文字。请搜索 WTP 关键字，或扫描二维码订阅：</p>
<p><img src="http://ww4.sinaimg.cn/thumbnail/68361562gw1e2iehwolnpj.jpg" alt=""></p>
</div>

    <div class="cat">
    
    <p><span>#</span> <a href="/category/blog/">blog</a></p>
    
    </div>

    <div class="relate">
        
        
        <p><span>PREV: </span><a rel="prev" href="/posts/11920727.html">我心目中的优秀 API</a></p>
        

        
        
        <p><span>NEXT: </span><a rel="next" href="/posts/11839787.html">放开你的思路</a></p>
        

        <p><span></span><a rel="all" href="/">VIEW ALL POSTS</a></p>
    </div>

    <div class="comments">
        <div id="disqus_thread"></div>
    </div>

</div>


<div class="footer">
    <div class="center">
        made by AcyOrt / powered by <a target="_blank" href="https://github.com/AcyOrt/acyort">AcyOrt</a> / <a target="_blank" href="/rss.xml">RSS</a>
    </div>
</div>

<script>

var menu = document.querySelector('.menu');

document.querySelector('.main').addEventListener('click', function(e) {
    if (e.target.classList.toString().indexOf('menuicon') > -1) {
        return menu.classList.toggle('active')
    } 

    return menu.classList.remove('active')
})

</script>




<script>
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//acyort.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>



</div>

</body>
</html>
