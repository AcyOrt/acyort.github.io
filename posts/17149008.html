<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="keywords" content="acyort, nodejs, blog" />
<meta name="description" content="A Node.js blog tool powered by GitHub." />
<link rel="icon" href="/icon.png" />
<link rel="stylesheet" href="/css/style.css" />

  <title>
Sea.js 源码解析（二） - AcyOrt
</title>
</head>

<body>

<div class="main">

<div class="header">
    <div class="center">
        <a class="logo" href="/">AcyOrt</a>

        <div class="menu">
            <div class="menuicon"></div>

            <div class="menuitem">
            
            <a href="/">home</a>
            
            <a href="/about">about</a>
            
            <a href="/">archives</a>
            
            </div>
        </div>
    </div>
</div>




<div id="post" class="center">

    <p class="time">July 24, 2013</p> 

    <h1 class="title">Sea.js 源码解析（二）</h1>

    <div class="content"><p><img src="https://f.cloud.github.com/assets/97227/847840/00b22ee2-f44a-11e2-8be3-1955a29c4a78.jpeg" alt="8c9a726bf3715831bfabc2d73ed420005f390bfa20c93-f3diwu_fw580"></p>
<p>昨天的文章，原以为没什么人看。毕竟微信公众帐号里，技术类的很少。在微信里阅读技术文章，也会比较累些。不习惯在微信里看技术的，可以点击底部的「原文链接」，所有文章都有同步到我的 GitHub 博客。大家可以选择适合自己的方式阅读。</p>
<h2 id="文件顺序">文件顺序</h2><p>昨天说了整体目录结构，今天来看看 src 目录。</p>
<pre><code>intro<span class="hljs-selector-class">.js</span>             -- 全局闭包头部
sea<span class="hljs-selector-class">.js</span>               -- 基本命名空间

util-lang<span class="hljs-selector-class">.js</span>         -- 语言增强
util-events<span class="hljs-selector-class">.js</span>       -- 简易事件机制
util-path<span class="hljs-selector-class">.js</span>         -- 路径处理
util-request<span class="hljs-selector-class">.js</span>      -- HTTP 请求
util-deps<span class="hljs-selector-class">.js</span>         -- 依赖提取

module<span class="hljs-selector-class">.js</span>            -- 核心代码
config<span class="hljs-selector-class">.js</span>            -- 配置
outro<span class="hljs-selector-class">.js</span>             -- 全局闭包尾部
</code></pre><p>推荐按顺序依次阅读。这个顺序，在 <a href="https://github.com/seajs/seajs/blob/master/Gruntfile.js">Gruntfile.js</a> 中有指明。 dist 目录下的 sea.js，就是以上文件按顺序合并生成的。</p>
<h2 id="大闭包">大闭包</h2><p>intro.js 和 outro.js 的代码很简单：</p>
<pre><code class="lang-js">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(global, undefined)</span> </span>{

  <span class="hljs-keyword">if</span> (global.seajs) {
    <span class="hljs-keyword">return</span>
  }
  <span class="hljs-comment">// 以上代码由 intro.js 提供</span>

  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// ...</span>

  <span class="hljs-comment">// 以下代码由 outro.js 提供</span>
})(<span class="hljs-keyword">this</span>);
</code></pre>
<p>这个代码组织方式，最初在 jQuery 项目中看见。几个细节：</p>
<ol>
<li><p>global 参数，传入的是全局的 this 值。这样，在浏览器环境中，global 是 window 对象。在 Node.js 环境中，global 则是 node 环境中的 global 对象。这是一个跨平台的兼容式写法。</p>
</li>
<li><p>第二个参数 undefined，由于实参中并没有传入，因此这个参数的值始终会是真正的 undefined。这种写法在类库中很普遍。传说中这样写的好处是，可以防止原生的 undefined 被覆盖掉。比如可以 <code>window.undefined = true</code>，这样所有 undefined 就不再是 undefined 了，很多代码就会出问题。这种说法理论上成立，但在我经历过的所有项目中，还没遇到过哪个前端会闲的蛋疼去覆盖原生的 undefined。Sea.js 中这么写，是为了另一个目的：压缩。如果不用 undefined 参数，undefined 是不会被压缩掉的。变成参数后，就一局部变量了，可以压缩成一个字符，能省不少字节。</p>
</li>
<li><p><code>if (global.seajs) { return }</code> 这句，是为了防止一个页面中有引入多个 sea.js。当有多个引入时，生效的永远是第一个。这种先到者优先的策略，是因为 Sea.js 本身的内部机制。Sea.js 是带状态的，先到者优先策略，可以保证状态的唯一性和一致性，否则会出现竞争，需要额外的逻辑来处理。</p>
</li>
<li><p>大闭包的写法，还有一个「额外的福利」，让单元测试变得简单。大家可以看 <a href="https://github.com/seajs/seajs/blob/master/tests/specs/util/test.html">tests/specs/util/test.html</a> ，在这个文件里，直接用 script 标签依次引入了上面的文件，但没有引入 intro.js 和 outro.js。这样，所有内部方法，自然而然就全部暴露到全局了。单元测试代码中，也就可以直接测试这些私有方法，很便捷。</p>
</li>
</ol>
<h2 id="基本命名空间">基本命名空间</h2><p>理解了大闭包，剩下的文件，就是一个个小模块，提供各种功能。来看 sea.js 文件。</p>
<pre><code class="lang-js"><span class="hljs-selector-tag">var</span> seajs = global<span class="hljs-selector-class">.seajs</span> = {
  version: <span class="hljs-string">"@VERSION"</span>
}

<span class="hljs-selector-tag">var</span> data = seajs<span class="hljs-selector-class">.data</span> = {}
</code></pre>
<p>定义了 seajs 变量，并放到全局对象中。其中 <code>@VERSION</code> 是占位符，在构建时，会从 package.json 中读取版本号来替换。</p>
<p>还定义了 data 变量，存放 seajs 相关的各种数据，比如配置信息、事件处理器等。</p>
<p>好了，就这么简单。</p>
<h2 id="最后">最后</h2><p>时间好快，应该又会有人抱怨这第二篇文章太水了。等不及的，可以提前去看看后续的源码。不然就跟着我的节奏来吧，这可是系列文章，我的预期是写上十篇以上。</p>
<p>最后，留两个小练习：</p>
<ol>
<li>为什么 <code>window.undefined = true</code> 能覆盖 <code>undefined</code>，但 <code>window.null = true</code> 却不能覆盖 <code>null</code>？</li>
<li>为什么要把 data 变量放到 <code>seajs.data</code> 上？</li>
</ol>
<p>（完）</p>
<p>题图：面朝大海，春暖花开。</p>
<hr>
<p>欢迎订阅 WTP（Web 技术与产品交流）微信公众帐号。WTP 关注技术、产品、自由梦，会偶尔推送一些原创文字。欢迎扫描二维码订阅：</p>
<p><img src="http://ww4.sinaimg.cn/thumbnail/68361562gw1e2iehwolnpj.jpg" alt=""></p>
</div>

    <div class="cat">
    
    <p><span>#</span> <a href="/category/blog/">blog</a></p>
    
    </div>

    <div class="relate">
        
        
        <p><span>PREV: </span><a rel="prev" href="/posts/17207547.html">工具与效率</a></p>
        

        
        
        <p><span>NEXT: </span><a rel="next" href="/posts/17089697.html">Sea.js 源码解析（一）</a></p>
        

        <p><span></span><a rel="all" href="/">View All Posts</a></p>
    </div>

    <div class="comments">
        <div id="disqus_thread"></div>
    </div>

</div>


<div class="footer">
    <div class="center">
        AcyOrt / powered by <a target="_blank" href="https://github.com/AcyOrt/acyort">AcyOrt</a> / <a target="_blank" href="/rss.xml">RSS</a>
    </div>
</div>

<script>

var menu = document.querySelector('.menu');

document.querySelector('.main').addEventListener('click', function(e) {
    if (e.target.classList.toString().indexOf('menuicon') > -1) {
        return menu.classList.toggle('active')
    } 

    return menu.classList.remove('active')
})

</script>




<script>
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//acyort.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>



</div>

</body>
</html>
