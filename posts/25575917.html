<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="keywords" content="acyort, nodejs, blog" />
<meta name="description" content="A Node.js blog tool powered by GitHub." />
<link rel="icon" href="//icon.png" />
<link rel="stylesheet" href="/css/style.css" />

  <title>
说说全栈工程师 - AcyOrt
</title>
</head>

<body>

<div class="main">

<div class="header">
    <div class="center">
        <a class="logo" href="/">AcyOrt</a>

        <div class="menu">
            <div class="menuicon"></div>

            <div class="menuitem">
            
            <a href="/">home</a>
            
            <a href="/">about</a>
            
            <a href="/">archives</a>
            
            </div>
        </div>
    </div>
</div>




<div id="post" class="center">

    <p class="time">January 14, 2014</p> 

    <h1 class="title">说说全栈工程师</h1>

    <div class="content"><p><img src="http://media-cache-ec0.pinimg.com/736x/5e/92/65/5e926593186d4c7475481abc632f76f7.jpg" alt=""></p>
<p>全栈工程师（Full Stack Developer）好像突然就火了，知乎、微博上都有讨论。这个概念在 2012 年时就有提出：<a href="http://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/">What is a Full Stack Developer?</a>，主要观点是：</p>
<blockquote>
<p>有这么一批人，他们对软件开发的很多层未必精通，但对每一层都很熟悉，他们对软件技术充满热情，这种人就是所谓的全栈工程师。</p>
</blockquote>
<p>对每一层都熟悉，究竟包含哪些层呢？作者的观点是：</p>
<ol>
<li>服务器、网络、运维。</li>
<li>数据模型。</li>
<li>业务逻辑。</li>
<li>API 层、Action 层、MVC。</li>
<li>UI 层。</li>
<li>用户体验。</li>
<li>理解用户与商业需求。</li>
</ol>
<p>如果对以上七层都很熟悉，同时精通一二，就是全栈工程师了。</p>
<p>这样来看其实并不难。比如对 Java 开发来说，第 3 层是工作重点，稍微有点追求的工程师，对 1、2、4、5 层也都会有一定的熟悉。对前端工程师来说，第 5 层是工作重点，然后对 3、4、6、7 层也会有一定熟悉度。其他职位，运维、DBA、测试等，也都有精通点，同时对周边的层会有熟悉度。</p>
<p>也就是说，大部分有点追求的工程师已经是四分之三栈工程师。反而单栈工程师很少很少，甚至不可能存在。</p>
<p>回到全栈工程师的定义，可以分解为三点：</p>
<ol>
<li>精通若干层。</li>
<li>熟悉所有层。</li>
<li>对软件技术充满热情。</li>
</ol>
<p>第 3 点很重要。未必要刻意去让自己熟悉所有层，如果能「对软件技术充满热情」，那么遇到陌生领域时，一个优秀的工程师会有能力去快速学习，从而慢慢地自然而然地就熟悉所有层，就莫名其妙成为全栈工程师了。</p>
<p><strong>全栈工程师是不给自己设限，是永远保持激情和学习欲望的一批人。</strong></p>
<p>另外想说一点，全栈工程师并不违背《国富论》提到的社会分工。在软件开发领域，分工依旧是提高效率的重要手段。但分工后，还有影响效率的一个重要因素：</p>
<p><strong>分工是否合理，是否已达成让合适的人做合适的事。</strong></p>
<p>从分工合理性的角度去考虑，会发现一些传统的分工未必是合适的。比如第 4 层 MVC 中的 View 和 Controller 层，Java 开发工程师真的是最合适的人选吗？这一层或许可以细化为：</p>
<p>4.1、Service、API、Model 层。
4.2、View、Router 等处理。</p>
<p>这样，4.1 依旧是后端开发擅长的领域，4.2 则很可能交给前端工程师来负责更合理。再次分工、分工合理性的判定，经常就需要跨界了解，需要全栈工程师的视角。</p>
<p>如果 4.2 交给前端来负责，Node 很可能就是当下更合适的技术选型。基于 Node 可以达成更合理的分工，有如 NCZ 的想法：</p>
<p><img src="http://img.hb.aicdn.com/40091e671b0bdee26e516ac050c6caec80885b8a12b87-7JgfFh_fw658" alt=""></p>
<p>全栈视角可以让我们重新去审视、去思考各个角色最合适去做什么，从而有可能促进更合理的分工协作。一旦发现了更合理的分工、需要对分工做出调整时，全栈就是一种自然而然的要求。比如基于 Node 的前后端分工协作，就需要前端工程师勇敢地去承担原来只是熟悉却并不精通的领域。如果能承担下来，无论对前端还是后端，效率上都会有提升，甚至带来一系列研发交付方式的变革。</p>
<p><strong>全栈的背后，是自由，是分工的更细化，是分工的更专业。</strong></p>
<p>（完）</p>
<p>题图：全栈烧饼。</p>
<hr>
<p>欢迎订阅 WTP（Web 技术与产品交流）微信公众帐号。WTP 关注技术、产品、自由梦，只推送原创文字。欢迎扫描二维码订阅：</p>
<p><img src="http://ww4.sinaimg.cn/thumbnail/68361562gw1e2iehwolnpj.jpg" alt=""></p>
</div>

    <div class="cat">
    
    <p><span>#</span> <a href="/category/blog/">blog</a></p>
    
    </div>

    <div class="relate">
        
        
        <p><span>PREV: </span><a rel="prev" href="/posts/25724757.html">我感受到的阿里</a></p>
        

        
        
        <p><span>NEXT: </span><a rel="next" href="/posts/25499547.html">Web 研发模式演变</a></p>
        

        <p><span></span><a rel="all" href="/">VIEW ALL POSTS</a></p>
    </div>

    <div class="comments">
        <div id="disqus_thread"></div>
    </div>

</div>


<div class="footer">
    <div class="center">
        made by AcyOrt / powered by <a target="_blank" href="https://github.com/AcyOrt/acyort">AcyOrt</a> / <a target="_blank" href="/rss.xml">RSS</a>
    </div>
</div>

<script>

var menu = document.querySelector('.menu');

document.querySelector('.main').addEventListener('click', function(e) {
    if (e.target.classList.toString().indexOf('menuicon') > -1) {
        return menu.classList.toggle('active')
    } 

    return menu.classList.remove('active')
})

</script>




<script>
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//acyort.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>



</div>

</body>
</html>
