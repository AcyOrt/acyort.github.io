<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="keywords" content="acyort, nodejs, blog" />
<meta name="description" content="A Node.js blog tool powered by GitHub." />
<link rel="icon" href="//icon.png" />
<link rel="stylesheet" href="/css/style.css" />

  <title>
重新认识 DRY 原则 - AcyOrt
</title>
</head>

<body>

<div class="main">

<div class="header">
    <div class="center">
        <a class="logo" href="/">AcyOrt</a>

        <div class="menu">
            <div class="menuicon"></div>

            <div class="menuitem">
            
            <a href="/">home</a>
            
            <a href="/">about</a>
            
            <a href="/">archives</a>
            
            </div>
        </div>
    </div>
</div>




<div id="post" class="center">

    <p class="time">April 25, 2013</p> 

    <h1 class="title">重新认识 DRY 原则</h1>

    <div class="content"><p><img src="https://f.cloud.github.com/assets/97227/423085/11b8033e-ad45-11e2-80bb-b187013e7013.jpeg" alt="d95bfb33f6ece74ab1725cbeaa9f97f864e56bd246ebb-eTrVhF_fw580"></p>
<p>今天在北京，白天晚上估计都没时间，一早起来写 WTP 先。</p>
<p>DRY 是 「Don&#39;t Repeat Yourself」的缩写，通常理解是：</p>
<blockquote>
<p>它意味着，当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法，并且改变现有的地方的代码让他们以一些合适的参数调用这个新的方法。（来自 <a href="http://www.php100.com/html/webkaifa/PHP/PHP/2009/0706/3062.html">程序员编程十条戒律</a>）</p>
</blockquote>
<p>简言之，就是：「不要出现重复代码」。</p>
<p>这看起来天经地义并且充满追求的一条法则，真的放之四海而皆准吗？</p>
<h2 id="从一个例子说起">从一个例子说起</h2><p>作为有追求的程序员，看到以下代码时经常会手痒：</p>
<p>a.js</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mix</span><span class="hljs-params">(s, r)</span> </span>{ ... }

exports.funcA = ...
</code></pre>
<p>b.js</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mix</span><span class="hljs-params">(s, r)</span> </span>{ ... }

exports.funcB = ...
</code></pre>
<p>在模块 a 和模块 b 的代码里，都有一个 mix 方法，明显存在重复。根据 DRY 法则，轻松重构之：</p>
<p>util.js</p>
<pre><code>exports<span class="hljs-selector-class">.mix</span> = ...
</code></pre><p>a.js</p>
<pre><code class="lang-js"><span class="hljs-selector-tag">var</span> util = require(<span class="hljs-string">'util'</span>)

exports<span class="hljs-selector-class">.funcA</span> = ...
</code></pre>
<p>b.js</p>
<pre><code class="lang-js"><span class="hljs-selector-tag">var</span> util = require(<span class="hljs-string">'util'</span>)

exports<span class="hljs-selector-class">.funcB</span> = ...
</code></pre>
<p>当代码规模比较小时，遵守 DRY，一切看起来很美妙。</p>
<h2 id="那些优雅而庞大的类库">那些优雅而庞大的类库</h2><p>当软件规模逐步扩大，DRY 往往会成为代码设计中的恶魔，会成为完美主义者的港湾。拿前端类库来说说这事。</p>
<p>熟悉 YUI3 的，对颗粒化应该不陌生。颗粒化的一个重要目标，就是减少代码重复，同时提高可拼装性。但带来的弊端也非常明显，比如 YUI3 的 Calendar 组件，如果想拿出来独立使用，得引入一堆文件：</p>
<pre><code><span class="hljs-selector-tag">yui-base</span> (<span class="hljs-number">34.78</span> KB)
<span class="hljs-selector-tag">intl-base</span> (<span class="hljs-number">0.49</span> KB)
<span class="hljs-selector-tag">oop</span> (<span class="hljs-number">2.14</span> KB)
<span class="hljs-selector-tag">event-custom-base</span> (<span class="hljs-number">11.92</span> KB)
<span class="hljs-selector-tag">event-custom-complex</span> (<span class="hljs-number">4.16</span> KB)
<span class="hljs-selector-tag">intl</span> (<span class="hljs-number">0.74</span> KB)
<span class="hljs-selector-tag">lang</span>/<span class="hljs-selector-tag">calendar</span> (<span class="hljs-number">0.00</span> KB)
<span class="hljs-selector-tag">lang</span>/<span class="hljs-selector-tag">calendar-base</span> (<span class="hljs-number">0.00</span> KB)
<span class="hljs-selector-tag">attribute-core</span> (<span class="hljs-number">4.97</span> KB)
<span class="hljs-selector-tag">attribute-observable</span> (<span class="hljs-number">1.04</span> KB)
<span class="hljs-selector-tag">attribute-extras</span> (<span class="hljs-number">0.72</span> KB)
<span class="hljs-selector-tag">attribute-base</span> (<span class="hljs-number">0.54</span> KB)
<span class="hljs-selector-tag">attribute-complex</span> (<span class="hljs-number">0.26</span> KB)
<span class="hljs-selector-tag">base-core</span> (<span class="hljs-number">4.18</span> KB)
<span class="hljs-selector-tag">base-observable</span> (<span class="hljs-number">1.22</span> KB)
<span class="hljs-selector-tag">base-base</span> (<span class="hljs-number">0.53</span> KB)
<span class="hljs-selector-tag">pluginhost-base</span> (<span class="hljs-number">0.91</span> KB)
<span class="hljs-selector-tag">pluginhost-config</span> (<span class="hljs-number">0.77</span> KB)
<span class="hljs-selector-tag">base-pluginhost</span> (<span class="hljs-number">0.17</span> KB)
<span class="hljs-selector-tag">classnamemanager</span> (<span class="hljs-number">0.34</span> KB)
<span class="hljs-selector-tag">features</span> (<span class="hljs-number">4.90</span> KB)
<span class="hljs-selector-tag">dom-core</span> (<span class="hljs-number">2.58</span> KB)
<span class="hljs-selector-tag">dom-base</span> (<span class="hljs-number">6.16</span> KB)
<span class="hljs-selector-tag">selector-native</span> (<span class="hljs-number">3.37</span> KB)
<span class="hljs-selector-tag">selector</span> (<span class="hljs-number">0.08</span> KB)
<span class="hljs-selector-tag">node-core</span> (<span class="hljs-number">9.52</span> KB)
<span class="hljs-selector-tag">node-base</span> (<span class="hljs-number">6.05</span> KB)
<span class="hljs-selector-tag">event-base</span> (<span class="hljs-number">7.14</span> KB)
<span class="hljs-selector-tag">event-synthetic</span> (<span class="hljs-number">3.63</span> KB)
<span class="hljs-selector-tag">event-focus</span> (<span class="hljs-number">2.03</span> KB)
<span class="hljs-selector-tag">dom-style</span> (<span class="hljs-number">3.14</span> KB)
<span class="hljs-selector-tag">node-style</span> (<span class="hljs-number">0.48</span> KB)
<span class="hljs-selector-tag">cssgrids</span> (<span class="hljs-number">1.37</span> KB)
<span class="hljs-selector-tag">skin-sam-widget-base</span> (<span class="hljs-number">0.00</span> KB)
<span class="hljs-selector-tag">widget-base</span> (<span class="hljs-number">6.13</span> KB)
<span class="hljs-selector-tag">widget-htmlparser</span> (<span class="hljs-number">0.90</span> KB)
<span class="hljs-selector-tag">widget-skin</span> (<span class="hljs-number">0.36</span> KB)
<span class="hljs-selector-tag">event-delegate</span> (<span class="hljs-number">1.88</span> KB)
<span class="hljs-selector-tag">node-event-delegate</span> (<span class="hljs-number">0.26</span> KB)
<span class="hljs-selector-tag">widget-uievents</span> (<span class="hljs-number">1.44</span> KB)
<span class="hljs-selector-tag">datatype-date-parse</span> (<span class="hljs-number">0.24</span> KB)
<span class="hljs-selector-tag">lang</span>/<span class="hljs-selector-tag">datatype-date-format</span> (<span class="hljs-number">0.00</span> KB)
<span class="hljs-selector-tag">datatype-date-format</span> (<span class="hljs-number">3.46</span> KB)
<span class="hljs-selector-tag">datatype-date-math</span> (<span class="hljs-number">1.35</span> KB)
<span class="hljs-selector-tag">skin-sam-calendar-base</span> (<span class="hljs-number">0.00</span> KB)
<span class="hljs-selector-tag">calendar-base</span> (<span class="hljs-number">15.41</span> KB)
<span class="hljs-selector-tag">plugin</span> (<span class="hljs-number">1.24</span> KB)
<span class="hljs-selector-tag">node-pluginhost</span> (<span class="hljs-number">0.64</span> KB)
<span class="hljs-selector-tag">dom-screen</span> (<span class="hljs-number">4.68</span> KB)
<span class="hljs-selector-tag">node-screen</span> (<span class="hljs-number">1.61</span> KB)
<span class="hljs-selector-tag">skin-sam-calendarnavigator</span> (<span class="hljs-number">0.00</span> KB)
<span class="hljs-selector-tag">calendarnavigator</span> (<span class="hljs-number">3.80</span> KB)
<span class="hljs-selector-tag">skin-sam-calendar</span> (<span class="hljs-number">0.00</span> KB)
<span class="hljs-selector-tag">calendar</span> (<span class="hljs-number">5.53</span> KB)
</code></pre><p>共 54 个模块，不信的可以自己去试下：<a href="http://yuilibrary.com/yui/configurator/">YUI Configurator</a> 。</p>
<p>虽然 YUI 提供了依赖的自动分析，但如此多的依赖，对维护来说，依旧是个恶魔。</p>
<p>DRY 的本意是提高可维护性，为何在以上场景中，看起来却并没有达成初衷？</p>
<h2 id="dry-的本义">DRY 的本义</h2><p>来看维基百科中的释义：</p>
<blockquote>
<p>In software engineering, don&#39;t repeat yourself (DRY) is a principle of software development aimed at reducing repetition of information of all kinds, especially useful in multi-tier architectures. The DRY principle is stated as &quot;Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.&quot; The principle has been formulated by Andy Hunt and Dave Thomas in their book The Pragmatic Programmer. </p>
</blockquote>
<p>大意如下：</p>
<blockquote>
<p>DRY 是软件开发领域的一条原则，目的是减少各种信息的重复，在多层架构中特别有用。DRY 的含义是：在一个系统中，任何知识点都应该拥有唯一、清晰、可信的表示。</p>
</blockquote>
<p>我们经常说中文博大精深，其实英文也一样，特别是涉及「原则」、「宗旨」等大词时。在上面的 DRY 的解释中，根本就没具体谈及代码重不重复的问题，更强调的是：</p>
<p><strong>在一个系统中，任何知识点都应该拥有唯一、清晰、可信的表示。</strong></p>
<p>「唯一」并不代表不重复，关键看你重复的是什么，不重复的又是什么。去年在设计 <a href="http://aralejs.org/">Arale</a> 类库时，写过一篇文章：<a href="https://github.com/lifesinger/lifesinger.github.com/issues/106">Arale 背后的一些设计理念</a>，其中谈到「适量重复」：</p>
<blockquote>
<p>第二个适度法则是适量重复。这是我的切身体会，有悖于传统的软件开发思想，但我觉得在前端界，适量重复比 DRY 更实用。</p>
<p>是个程序员可能都听过 DRY （Don&#39;t Repeat Yourself），这条法则非常好，在大部分情况下都是对的。</p>
<p>然而在构建前端类库时，我觉得遵守 DRY 会很危险。</p>
<p>如果你追求代码的不重复，那么你在写 a 和 b 组件时，会把公用部分抽取为 c，不断重复这个追求，最后就会得到一个非常庞大的依赖结构图，比如 YUI3 就是这样。YUI3 追求颗粒化，表面上看颗粒化可以让自定义打包更灵活更优秀，但实际上，颗粒化的粒度非常关键，像目前 YUI3 的粒度太小，导致的问题是，实际上你若真去把 dom / event / node 等模块打包出来，其实会比 jQuery 大出不少，不光达不到实际的期望效果，还牵三挂四，开发起来并不方便，虽然 combo 服务可以缓解一点。</p>
<p>对于 DRY 法则，我的理解是，必须要非常小心把握好两点：</p>
<ol>
<li>究竟不应该重复的是什么？</li>
<li>粒度如何？</li>
</ol>
</blockquote>
<p>DRY 中的不重复，真正要考虑的是：</p>
<ol>
<li><p><strong>职责问题：每个模块的职责究竟是什么？确定范畴、界限非常重要。要明确每个功能的职责，并在同一个系统中，保持其唯一性。</strong></p>
</li>
<li><p><strong>粒度问题：模块的粒度问题。细粒度还是粗粒度？根据具体场景来做合适的取舍、决策。</strong></p>
</li>
</ol>
<p>把职责和粒度考虑清楚，保证其在同一个系统中不重复，这才是我眼中的 DRY 原则。至于代码是否重复，并不是关键。</p>
<h2 id="在-arale-中的尝试">在 Arale 中的尝试</h2><p>在 Arale 中，我们制定了几条法则：「开放、简单、易用、适度灵活、适量重复」。遵循这几条法则，我们来看 Arale 中的 <a href="http://aralejs.org/calendar/">Calendar</a> 组件：</p>
<pre><code>base<span class="hljs-selector-class">.js</span>
widget<span class="hljs-selector-class">.js</span>
overlay<span class="hljs-selector-class">.js</span>
jquery<span class="hljs-selector-class">.js</span>
handlebars<span class="hljs-selector-class">.js</span>
moment<span class="hljs-selector-class">.js</span>
calendar.js
</code></pre><p>看起来也不少，但与 YUI3 的 54 个依赖相比，Arale 的更简单清晰、易于维护。</p>
<p>特别注意以上组件中，比如 jquery、handlebars 等文件的代码里，仔细去看的话，其实存在着不少重复代码。包括 Arale 自身的组件 base 和 widget 的代码中，我们也故意留了一些重复代码，而没有去做进一步「追求完美」的提取封装。</p>
<p>这种「追求职责不重复、允许适量代码重复」带来的好处是：</p>
<ol>
<li><strong>依赖层级更简单清晰。</strong></li>
<li><strong>内部修改变得更方便。</strong> 比如 jquery 里的 each 方法，和 moment 中的 each 方法，可以各自有自己的选择，根据实际场景优化。</li>
</ol>
<p>这与 Go 语言的设计有很多相似的地方：<a href="http://www.oschina.net/translate/go-at-google-language-design-in-the-service-of-software-engineering">Go在谷歌：以软件工程为目的的语言设计</a>。</p>
<h2 id="小结">小结</h2><p>肚子有点饿了，我的核心观点是：</p>
<p><strong>DRY 中最重要的，是在具体场景中，去想清楚什么是坚决不能重复的，同时想清楚什么是允许重复的。而非简单粗暴去追求代码的零重复。</strong> （代码的零重复与 0 bug 一样邪恶）</p>
<p>DRY 用在生活中更具诗意： <strong>让每一天，都与你的过往不同。</strong></p>
<p>文 / 玉伯</p>
<p>题图：几片自然风干的叶子，清晰、美丽。</p>
<hr>
<p>欢迎订阅 WTP（Web 技术与产品交流）微信公众帐号。WTP 关注技术、产品、自由梦，在每个工作日（偶尔休息日）会定期推送一篇原创文字。欢迎扫描二维码订阅：</p>
<p><img src="http://ww4.sinaimg.cn/thumbnail/68361562gw1e2iehwolnpj.jpg" alt=""></p>
</div>

    <div class="cat">
    
    <p><span>#</span> <a href="/category/blog/">blog</a></p>
    
    </div>

    <div class="relate">
        
        
        <p><span>PREV: </span><a rel="prev" href="/posts/13667800.html">疯狂原始人</a></p>
        

        
        
        <p><span>NEXT: </span><a rel="next" href="/posts/13534870.html">事件触发的一个细节设计（下）</a></p>
        

        <p><span></span><a rel="all" href="/">VIEW ALL POSTS</a></p>
    </div>

    <div class="comments">
        <div id="disqus_thread"></div>
    </div>

</div>


<div class="footer">
    <div class="center">
        made by AcyOrt / powered by <a target="_blank" href="https://github.com/AcyOrt/acyort">AcyOrt</a> / <a target="_blank" href="/rss.xml">RSS</a>
    </div>
</div>

<script>

var menu = document.querySelector('.menu');

document.querySelector('.main').addEventListener('click', function(e) {
    if (e.target.classList.toString().indexOf('menuicon') > -1) {
        return menu.classList.toggle('active')
    } 

    return menu.classList.remove('active')
})

</script>




<script>
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//acyort.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>



</div>

</body>
</html>
